"""
Insight Rules - Evidence-gated pattern detection

Each rule decides when to show specific insights based on data patterns
"""

from typing import Protocol, List, Dict, Any
from dataclasses import dataclass
import pandas as pd
from .context import ViewContext
from . import calc


# ============================================================================
# INSIGHT PROTOCOL
# ============================================================================

@dataclass
class Insight:
    """Single insight generated by a rule"""
    kind: str  # 'summary', 'key_finding', 'recommendation', 'investment'
    key: str   # Unique identifier
    payload: Dict[str, Any]  # Data for template rendering


class InsightRule(Protocol):
    """Protocol for insight rules"""

    name: str
    requirements: Dict[str, Any]  # e.g., {'min_n': 30, 'min_groups': 3}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        """Check if this rule should fire"""
        ...

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        """Generate insights"""
        ...


# ============================================================================
# RULE REGISTRY
# ============================================================================

class InsightRegistry:
    """Registry of available insight rules"""

    def __init__(self):
        self._rules: Dict[str, InsightRule] = {}
        self._metric_rules: Dict[str, List[str]] = {}

    def register(self, rule: InsightRule):
        """Register a rule"""
        self._rules[rule.name] = rule

    def for_metric(self, metric_id: str, rule_names: List[str]) -> List[InsightRule]:
        """Get rules applicable to a metric"""
        return [self._rules[name] for name in rule_names if name in self._rules]


INSIGHT_REGISTRY = InsightRegistry()


# ============================================================================
# CORE RULES
# ============================================================================

class RankingRule:
    """Generate ranking insights for all-regions view"""

    name = "ranking"
    requirements = {'min_groups': 3}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        # Only for all-regions or subset with multiple groups
        return (ctx.n_groups >= 3 and
                metrics.get('distribution') is not None and
                metrics.get('extrema') is not None)

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        dist = metrics['distribution']
        extrema = metrics.get('extrema')

        if not extrema:
            return []

        best = extrema['max_row']
        worst = extrema['min_row']
        # CRITICAL FIX: Use population-weighted national average from metrics, not simple mean
        # This ensures consistency between chart annotations and narrative text
        national_avg = metrics.get('national_avg', dist['mean'])

        # Calculate percentages
        best_pct_above = ((best['value'] / national_avg) - 1) * 100
        worst_pct_below = (1 - (worst['value'] / national_avg)) * 100
        variation_factor = best['value'] / worst['value'] if worst['value'] != 0 else 0

        return [Insight(
            kind='summary',
            key='ranking',
            payload={
                'best': best,
                'worst': worst,
                'national_avg': national_avg,
                'best_pct_above': best_pct_above,
                'worst_pct_below': worst_pct_below,
                'variation_factor': variation_factor,
                'unit': metrics.get('unit', '')
            }
        )]


class SingleRegionPositioningRule:
    """Generate positioning insight for single-region view"""

    name = "single_region_positioning"
    requirements = {}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        return ctx.scope == "single_region" and 'this_region' in metrics

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        region = metrics['this_region']
        national_avg = metrics['national_avg']
        # Use total_regions from this_region dict (calculated against full dataset)
        total_regions = region.get('total_regions', metrics.get('total_regions', 9))

        return [Insight(
            kind='summary',
            key='single_region_position',
            payload={
                'region_name': region['name'],
                'value': region['value'],
                'rank': region['rank'],
                'total_regions': total_regions,
                'pct_vs_national': region['pct_vs_national'],
                'national_avg': national_avg,
                'population': region.get('population', 0) / 1e6,  # Convert to millions for template
                'unit': metrics.get('unit', '')
            }
        )]


class SubsetSummaryRule:
    """Generate descriptive summary for subset/filtered views (e.g., Urban/Rural)"""

    name = "subset_summary"
    requirements = {}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        return ctx.scope == "subset" and ctx.n_groups == 1

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        # Extract basic stats from the single aggregated row
        dist = metrics.get('distribution', {})
        mean_value = dist.get('mean', 0)
        national_avg = metrics.get('national_avg', 0)

        # Calculate difference from national
        pct_vs_national = ((mean_value / national_avg) - 1) * 100 if national_avg > 0 else 0

        # Determine filter description
        urban_rural = ctx.filters.get('urban_rural', '')
        region = ctx.region if ctx.region else 'All regions'

        if urban_rural:
            filter_desc = f"{urban_rural} areas in {region}" if ctx.region else f"{urban_rural} areas nationwide"
        else:
            filter_desc = f"{region} (filtered subset)"

        return [Insight(
            kind='summary',
            key='subset_description',
            payload={
                'filter_desc': filter_desc,
                'value': mean_value,
                'pct_vs_national': pct_vs_national,
                'national_avg': national_avg,
                'unit': metrics.get('unit', ''),
                'above_below': 'above' if pct_vs_national > 0 else 'below'
            }
        )]


class CorrelationRule:
    """Generate correlation insight"""

    name = "correlation"
    requirements = {'min_n': 30}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        corr = metrics.get('correlation')
        return corr is not None and corr['significant']

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        corr = metrics['correlation']

        return [Insight(
            kind='key_finding',
            key='correlation',
            payload={
                'r': corr['r'],
                'p': corr['p'],
                'n': corr['n'],
                'strength': corr['strength'],
                'x_name': metrics.get('x_name', 'X'),
                'y_name': metrics.get('y_name', 'Y')
            }
        )]


class OutlierRule:
    """Identify and call out outliers"""

    name = "outlier"
    requirements = {'min_groups': 5}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        dist = metrics.get('distribution')
        return dist is not None and dist.get('n_outliers', 0) > 0

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        dist = metrics['distribution']
        outliers = metrics.get('outlier_regions', [])

        return [Insight(
            kind='key_finding',
            key='outliers',
            payload={
                'n_outliers': dist['n_outliers'],
                'outlier_regions': outliers,
                'iqr': dist['iqr'],
                'unit': metrics.get('unit', '')
            }
        )]


class GapToInvestmentRule:
    """Calculate investment requirement for regions below target"""

    name = "gap_to_investment"
    requirements = {'min_groups': 1}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        return 'gaps' in metrics and metrics['gaps']['n_below_target'] > 0

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        gaps = metrics['gaps']
        investment = metrics.get('investment', {})
        bcr_result = metrics.get('bcr', {})

        return [
            Insight(
                kind='recommendation',
                key='gap_investment',
                payload={
                    'n_below_target': gaps['n_below_target'],
                    'total_pop_affected': gaps['total_pop_affected'],
                    'investment_npv': investment.get('npv', 0),
                    'annual_cost': investment.get('annual_cost', 0),
                    'bcr': bcr_result.get('bcr', 0),
                    'vfm_category': bcr_result.get('vfm_category', ''),
                    'horizon_years': investment.get('horizon_years', 10),
                    'gap_units': investment.get('gap_units', 0),
                    'unit': metrics.get('unit', '')
                }
            ),
            Insight(
                kind='investment',
                key='investment_detail',
                payload={
                    'npv': investment.get('npv', 0),
                    'annual_cost': investment.get('annual_cost', 0),
                    'total_undiscounted': investment.get('total_undiscounted', 0),
                    'horizon_years': investment.get('horizon_years', 10)
                }
            )
        ]


class VariationRule:
    """Analyze variation/dispersion in data"""

    name = "variation"
    requirements = {'min_groups': 3}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        dist = metrics.get('distribution')
        return dist is not None and dist.get('cv', 0) > 0.1  # CV > 10%

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        dist = metrics['distribution']

        # Interpret CV
        cv = dist['cv']
        if cv < 0.2:
            variation_label = "low variation"
        elif cv < 0.4:
            variation_label = "moderate variation"
        elif cv < 0.6:
            variation_label = "high variation"
        else:
            variation_label = "very high variation"

        return [Insight(
            kind='key_finding',
            key='variation',
            payload={
                'cv': cv,
                'variation_label': variation_label,
                'std': dist['std'],
                'mean': dist['mean'],
                'iqr': dist['iqr']
            }
        )]


class QuartileComparisonRule:
    """Compare top 25% vs bottom 25% (quartile analysis for correlations)"""

    name = "quartile_comparison"
    requirements = {'min_n': 30}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        quartile = metrics.get('quartile_comparison')
        return quartile is not None and quartile.get('gap_pct') is not None

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        quartile = metrics['quartile_comparison']

        # Determine if gap is positive (high has more) or negative (high has less)
        gap_pct = quartile['gap_pct']
        gap_direction = "more" if gap_pct > 0 else "less"

        # Policy interpretation based on magnitude
        abs_gap = abs(gap_pct)
        if abs_gap > 30:
            severity = "critical"
            policy_priority = "high"
        elif abs_gap > 15:
            severity = "significant"
            policy_priority = "medium"
        else:
            severity = "moderate"
            policy_priority = "low"

        return [Insight(
            kind='key_finding',
            key='quartile_comparison',
            payload={
                'high_label': quartile['high_label'],
                'low_label': quartile['low_label'],
                'high_value': quartile['high_value'],
                'low_value': quartile['low_value'],
                'gap_pct': gap_pct,
                'gap_direction': gap_direction,
                'abs_gap': abs_gap,
                'severity': severity,
                'policy_priority': policy_priority,
                'metric_name': quartile.get('metric_name', 'coverage'),
                'dimension': quartile.get('dimension', 'characteristic')
            }
        )]


class PowerLawRule:
    """Interpret power law relationships (economies/diseconomies of scale)"""

    name = "power_law"
    requirements = {'min_n': 30}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        power_law = metrics.get('power_law')
        return power_law is not None and power_law.get('slope') is not None

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        pl = metrics['power_law']

        slope = pl['slope']
        p_value = pl['p_value']

        # Interpret slope
        if slope < 0.9:
            scaling_type = "economies of scale"
            efficiency = "efficient"
            interpretation = "Larger populations receive proportionally MORE stops per person"
        elif slope > 1.1:
            scaling_type = "diseconomies of scale"
            efficiency = "inefficient"
            interpretation = "Larger populations require disproportionately MORE stops per person"
        else:
            scaling_type = "linear scaling"
            efficiency = "proportional"
            interpretation = "Stop provision scales approximately linearly with population"

        return [Insight(
            kind='key_finding',
            key='power_law',
            payload={
                'slope': slope,
                'p_value': p_value,
                'r': pl.get('r', 0),
                'scaling_type': scaling_type,
                'efficiency': efficiency,
                'interpretation': interpretation,
                'significant': p_value < 0.05
            }
        )]


class EfficiencyRule:
    """Identify over/under-served areas based on efficiency deviation"""

    name = "efficiency"
    requirements = {'min_n': 30}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        efficiency = metrics.get('efficiency_analysis')
        return efficiency is not None and efficiency.get('n_underserved', 0) > 0

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        eff = metrics['efficiency_analysis']

        return [Insight(
            kind='recommendation',
            key='efficiency',
            payload={
                'n_underserved': eff['n_underserved'],
                'pop_underserved': eff['pop_underserved'],
                'additional_stops_needed': eff['additional_stops_needed'],
                'pct_underserved_lsoas': eff['pct_underserved_lsoas'],
                'pct_underserved_pop': eff['pct_underserved_pop']
            }
        )]


# Register all rules
INSIGHT_REGISTRY.register(RankingRule())
INSIGHT_REGISTRY.register(SingleRegionPositioningRule())
INSIGHT_REGISTRY.register(SubsetSummaryRule())
INSIGHT_REGISTRY.register(CorrelationRule())
INSIGHT_REGISTRY.register(OutlierRule())
INSIGHT_REGISTRY.register(GapToInvestmentRule())
INSIGHT_REGISTRY.register(VariationRule())
INSIGHT_REGISTRY.register(QuartileComparisonRule())
INSIGHT_REGISTRY.register(PowerLawRule())
INSIGHT_REGISTRY.register(EfficiencyRule())
