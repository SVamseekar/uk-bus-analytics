"""
Insight Rules - Evidence-gated pattern detection

Each rule decides when to show specific insights based on data patterns
"""

from typing import Protocol, List, Dict, Any
from dataclasses import dataclass
import pandas as pd
from .context import ViewContext
from . import calc


# ============================================================================
# INSIGHT PROTOCOL
# ============================================================================

@dataclass
class Insight:
    """Single insight generated by a rule"""
    kind: str  # 'summary', 'key_finding', 'recommendation', 'investment'
    key: str   # Unique identifier
    payload: Dict[str, Any]  # Data for template rendering


class InsightRule(Protocol):
    """Protocol for insight rules"""

    name: str
    requirements: Dict[str, Any]  # e.g., {'min_n': 30, 'min_groups': 3}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        """Check if this rule should fire"""
        ...

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        """Generate insights"""
        ...


# ============================================================================
# RULE REGISTRY
# ============================================================================

class InsightRegistry:
    """Registry of available insight rules"""

    def __init__(self):
        self._rules: Dict[str, InsightRule] = {}
        self._metric_rules: Dict[str, List[str]] = {}

    def register(self, rule: InsightRule):
        """Register a rule"""
        self._rules[rule.name] = rule

    def for_metric(self, metric_id: str, rule_names: List[str]) -> List[InsightRule]:
        """Get rules applicable to a metric"""
        return [self._rules[name] for name in rule_names if name in self._rules]


INSIGHT_REGISTRY = InsightRegistry()


# ============================================================================
# CORE RULES
# ============================================================================

class RankingRule:
    """Generate ranking insights for all-regions view"""

    name = "ranking"
    requirements = {'min_groups': 3}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        # Only for all-regions or subset with multiple groups
        return (ctx.n_groups >= 3 and
                metrics.get('distribution') is not None and
                metrics.get('extrema') is not None)

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        dist = metrics['distribution']
        extrema = metrics.get('extrema')

        if not extrema:
            return []

        best = extrema['max_row']
        worst = extrema['min_row']
        national_avg = dist['mean']

        # Calculate percentages
        best_pct_above = ((best['value'] / national_avg) - 1) * 100
        worst_pct_below = (1 - (worst['value'] / national_avg)) * 100
        variation_factor = best['value'] / worst['value'] if worst['value'] != 0 else 0

        return [Insight(
            kind='summary',
            key='ranking',
            payload={
                'best': best,
                'worst': worst,
                'national_avg': national_avg,
                'best_pct_above': best_pct_above,
                'worst_pct_below': worst_pct_below,
                'variation_factor': variation_factor,
                'unit': metrics.get('unit', '')
            }
        )]


class SingleRegionPositioningRule:
    """Generate positioning insight for single-region view"""

    name = "single_region_positioning"
    requirements = {}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        return ctx.scope == "single_region" and 'this_region' in metrics

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        region = metrics['this_region']
        national_avg = metrics['national_avg']
        total_regions = metrics.get('total_regions', 9)

        return [Insight(
            kind='summary',
            key='single_region_position',
            payload={
                'region_name': region['name'],
                'value': region['value'],
                'rank': region['rank'],
                'total_regions': total_regions,
                'pct_vs_national': region['pct_vs_national'],
                'national_avg': national_avg,
                'unit': metrics.get('unit', '')
            }
        )]


class CorrelationRule:
    """Generate correlation insight"""

    name = "correlation"
    requirements = {'min_n': 30}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        corr = metrics.get('correlation')
        return corr is not None and corr['significant']

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        corr = metrics['correlation']

        return [Insight(
            kind='key_finding',
            key='correlation',
            payload={
                'r': corr['r'],
                'p': corr['p'],
                'n': corr['n'],
                'strength': corr['strength'],
                'x_name': metrics.get('x_name', 'X'),
                'y_name': metrics.get('y_name', 'Y')
            }
        )]


class OutlierRule:
    """Identify and call out outliers"""

    name = "outlier"
    requirements = {'min_groups': 5}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        dist = metrics.get('distribution')
        return dist is not None and dist.get('n_outliers', 0) > 0

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        dist = metrics['distribution']
        outliers = metrics.get('outlier_regions', [])

        return [Insight(
            kind='key_finding',
            key='outliers',
            payload={
                'n_outliers': dist['n_outliers'],
                'outlier_regions': outliers,
                'iqr': dist['iqr'],
                'unit': metrics.get('unit', '')
            }
        )]


class GapToInvestmentRule:
    """Calculate investment requirement for regions below target"""

    name = "gap_to_investment"
    requirements = {'min_groups': 1}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        return 'gaps' in metrics and metrics['gaps']['n_below_target'] > 0

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        gaps = metrics['gaps']
        investment = metrics.get('investment', {})
        bcr_result = metrics.get('bcr', {})

        return [
            Insight(
                kind='recommendation',
                key='gap_investment',
                payload={
                    'n_below_target': gaps['n_below_target'],
                    'total_pop_affected': gaps['total_pop_affected'],
                    'investment_npv': investment.get('npv', 0),
                    'annual_cost': investment.get('annual_cost', 0),
                    'bcr': bcr_result.get('bcr', 0),
                    'vfm_category': bcr_result.get('vfm_category', ''),
                    'horizon_years': investment.get('horizon_years', 10),
                    'gap_units': investment.get('gap_units', 0),
                    'unit': metrics.get('unit', '')
                }
            ),
            Insight(
                kind='investment',
                key='investment_detail',
                payload={
                    'npv': investment.get('npv', 0),
                    'annual_cost': investment.get('annual_cost', 0),
                    'total_undiscounted': investment.get('total_undiscounted', 0),
                    'horizon_years': investment.get('horizon_years', 10)
                }
            )
        ]


class VariationRule:
    """Analyze variation/dispersion in data"""

    name = "variation"
    requirements = {'min_groups': 3}

    def applies(self, ctx: ViewContext, metrics: Dict[str, Any]) -> bool:
        dist = metrics.get('distribution')
        return dist is not None and dist.get('cv', 0) > 0.1  # CV > 10%

    def emit(self, ctx: ViewContext, metrics: Dict[str, Any]) -> List[Insight]:
        dist = metrics['distribution']

        # Interpret CV
        cv = dist['cv']
        if cv < 0.2:
            variation_label = "low variation"
        elif cv < 0.4:
            variation_label = "moderate variation"
        elif cv < 0.6:
            variation_label = "high variation"
        else:
            variation_label = "very high variation"

        return [Insight(
            kind='key_finding',
            key='variation',
            payload={
                'cv': cv,
                'variation_label': variation_label,
                'std': dist['std'],
                'mean': dist['mean'],
                'iqr': dist['iqr']
            }
        )]


# Register all rules
INSIGHT_REGISTRY.register(RankingRule())
INSIGHT_REGISTRY.register(SingleRegionPositioningRule())
INSIGHT_REGISTRY.register(CorrelationRule())
INSIGHT_REGISTRY.register(OutlierRule())
INSIGHT_REGISTRY.register(GapToInvestmentRule())
INSIGHT_REGISTRY.register(VariationRule())
